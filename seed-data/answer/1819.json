{"comments":[], "Body":"<p>I have written a jQuery wrapper method to align interlinear glosses.  </p>\n\n<p>The nice thing about this approach is that it minimizes the HTML markup that you need to put into the lines of your linguistic data.  For example, something like: </p>\n\n<pre><code>&lt;div class=\"align-me\"&gt;\n  &lt;div&gt;les chiens dormaient&lt;/div&gt;\n  &lt;div&gt;le-s chien-s dorm-ai-ent&lt;/div&gt;\n  &lt;div&gt;DET-PL dog-PL sleep-IMPF-3PL&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>could be aligned by calling:</p>\n\n<pre><code>$('.align-me').igt();\n</code></pre>\n\n<p>I have not yet extensively debugged this, but here's the code.  Comments/suggestions welcome:</p>\n\n<pre><code>(function($) {\n    // IGT - Interlinear Gloss Text -- this wrapped set method correctly aligns\n    //  words in interlinear gloss text format into columns.  Each element of\n    //  the set is expected to contain two or more elements and the text of\n    //  each of these sub-elements is considered to be the line.  In the\n    //  following example, 'les chiens', 'le-s chien-s' and 'DET-PL dog-PL' are\n    //  the lines:\n    //\n    //    &lt;div class=\"align-me\"&gt;\n    //      &lt;div&gt;les chiens&lt;/div&gt;\n    //      &lt;div&gt;le-s chien-s&lt;/div&gt;\n    //      &lt;div&gt;DET-PL dog-PL&lt;/div&gt;\n    //    &lt;/div&gt;\n    //\n    //  Basic usage:\n    //\n    //    $('div.align-me').igt();\n    //\n    //  Usage with options:\n    //\n    //    $('div.align-me').igt({buffer: 20, lineGroupBuffer: 5, indent: 60,\n    //                          minLineWidthAsPerc: 75});\n\n    $.fn.igt = function (options) {\n\n        // Align words in each element of the wrapped set\n        $(this).each(function () {\n\n            var container = $(this);\n\n            // Each child is a line whose words may need alignment\n            var children = $(this).children();\n\n            // spanWidths holds the width of each span in each line; it will\n            //  look something like [[49, 32, 40], [66, 49, 40], [61, 99, 25]]\n            var spanWidths = [];  \n\n            // colWidths holds the width of each column, i.e., the width of the\n            //  longest &lt;span&gt;-wrapped word with index x, e.g., [66, 99, 40]\n            var colWidths = [];\n\n            // lineHeights holds height of each line\n            var lineHeights = []; \n\n\n            ////////////////////////////////////////////////////////////////////\n            // OPTIONS //\n            ////////////////////////////////////////////////////////////////////\n\n            if (options === undefined) options = {};\n\n            // Number of pixels to put between each span\n            var buffer = (options.buffer === undefined) ? 30: options.buffer;\n\n            // Number of pixels to put between groups of lines (\"lineGroups\")\n            var lineGroupBuffer = (options.lineGroupBuffer === undefined) ?\n                                    10 : options.lineGroupBuffer;\n\n            // Number of pixels to indent each subsequent line\n            var indent = (options.indent === undefined) ? 40 : options.indent;\n\n            // Minimum width of a line as a percentage of the container's width\n            var minLineWidthAsPerc = (options.minLineWidthAsPerc === undefined) ?\n                                    50 : options.minLineWidthAsPerc;\n\n            // Line Group Class: class to give to line groups\n            var lineGroupClass = (options.lineGroupClass === undefined) ?\n                            'old-form-igt-line-group': options.lineGroupClass;\n\n            ////////////////////////////////////////////////////////////////////\n            // FUNCTIONS //\n            ////////////////////////////////////////////////////////////////////\n\n            // Spanify -- input: line of text; output: line with each word\n            //  enclosed in a span tag\n            function spanify(elementText) {\n                return $.map(elementText.replace(/\\s\\s+/g, ' ').split(' '),\n                    function (word) {\n                        return '&lt;span style=\"white-space: nowrap;\"&gt;' + word +\n                        '&lt;/span&gt;';\n                    }\n                ).join('');\n            }\n\n            // Get Greatest Width -- return the greatest width among the words\n            //  in the same 'column'.\n            function getGreatestWidth(widths, index, spanIndex) {\n                if (colWidths[spanIndex] === undefined) {\n\n                    // E.g., from [[49, 32, 40], [66, 49], [61, 99, 25]],\n                    //  return [40, 25] (assuming spanIndex = 2)\n                    widths = $.map(widths, function (widthSet) {\n                        if (widthSet.length == widths[index].length)\n                            return widthSet[spanIndex];\n                        else\n                            return 0;\n                    });\n\n                    result = Math.max.apply(Math, widths); // Get the widest\n                    colWidths[spanIndex] = result;  // Remember for later\n                    return result;\n\n                } else {\n                    // We know max width of this column from previous iterations\n                    return colWidths[spanIndex];\n                }\n            }\n\n            // Set Width -- set the width of the span to the width of the widest\n            //  span in the same column PLUS the buffer.\n            function setWidth(index, spanIndex, span) {\n                greatestWidth = getGreatestWidth(spanWidths, index, spanIndex);\n                $(span).css({display: 'inline-block',\n                            width: greatestWidth + buffer});\n            }\n\n            // Sum -- sum all integers in an array (c'mon Javascript!)\n            function sum(array) {\n                result = 0;\n                for (i = 0;i &lt; array.length;i += 1)\n                    result += array[i];\n                return result;\n            }\n\n            // Get New Max Width: get the max width of a \"line group\" based on\n            //  the current max width, indent and minLineWidthAsPerc\n            function getNewMaxWidth(currentMaxWidth, minLineWidth) {\n                if ((currentMaxWidth - indent) &gt; minLineWidth) {\n                    return currentMaxWidth - indent;\n                } else {\n                    // Sorry, we can't reduce the width any further\n                    return currentMaxWidth;\n                }\n            }\n\n\n            ////////////////////////////////////////////////////////////////////\n            // ALIGN THE WORDS IN THE LINES ALREADY //\n            ////////////////////////////////////////////////////////////////////\n\n            // Enclose each word of each child in span tags, record the width\n            //  of each such span tag and the height of each line\n            children.each(function (index, child) {\n                // wrap words in spans\n                $(child).html(spanify($(child).text()));\n\n                // record the width of each span\n                var widths = [];\n                $('span', child).each(function (index, span) {\n                    widths.push($(span).width());\n                });\n                spanWidths.push(widths);\n\n                // Record the height of each line\n                lineHeights.push($($('span', child)[0]).height());\n\n            });\n\n            // linesToColumnify is an array of indices representing the lines\n            //  whose span-wrapped words need to be aligned.  Such lines have\n            //  a word count that is greater than one and equal to that of all\n            //  subsequent lines.\n            var linesToColumnify = [];\n            $.each(spanWidths, function (index, line) {\n                // isColumnable returns true if the last line has more than two\n                //  words and all lines from this one on down have the same word\n                //  count\n                function isColumnable(index, line) {\n                    if (spanWidths[spanWidths.length - 1].length &lt; 2)\n                        return false;\n                    for (var i = index + 1; i &lt; spanWidths.length; i++) {\n                        if (spanWidths[i].length !== spanWidths[index].length)\n                            return false;\n                    }\n                    return true;\n                }\n                if (isColumnable(index, line)) linesToColumnify.push(index);\n            });\n\n            // Set the width of each span tag to the width of the longest span\n            //  tag in the same 'column' plus the buffer\n            children.each(function (index, child) {\n                // Only alter the width of spans inside of columnable lines\n                if (linesToColumnify.indexOf(index) !== -1) {\n                    $('span', child).each(function (spanIndex, span) {\n                        setWidth(index, spanIndex, span);\n                    });\n                }\n            });\n\n            // If the container's height is not equal to the sum of the line\n            //  heights, we have lines wrapping and need to fix that by breaking\n            //  the lines into multiple lines.\n            var containerHeight = $(this).height();\n            if (containerHeight !== sum(lineHeights)) {\n                var containerWidth = $(this).width();\n                var minLineWidth = Math.round(minLineWidthAsPerc / 100 *\n                                                containerWidth);\n\n                // Create the lineGroups list of objects; this tells us the max\n                //  width of each line and, indirectly via the spanWidths object,\n                //  the slice of &lt;span&gt;-wrapped words we want in each line.\n                var lineGroups = [{maxWidth: containerWidth, indent: 0,\n                                 spanWidths: []}];\n                $.each(colWidths, function (index, width) {\n                    lineGroup = lineGroups[lineGroups.length - 1];\n                    if ((sum(lineGroup.spanWidths) + width + buffer)\n                        &lt; lineGroup.maxWidth) {\n                        lineGroup.spanWidths.push(width + buffer);\n                    } else {\n\n                        lineGroups.push({maxWidth:\n                            getNewMaxWidth(lineGroup.maxWidth, minLineWidth),\n                            spanWidths: [width + buffer]});\n                    }\n                });\n\n                // Create a new container that has the lines broken up,\n                //  grouped and indented appropriately.\n                var newContainer = $('&lt;div&gt;');\n                var begin = 0;\n                previousIndent = 0;\n                $.each(lineGroups, function (index, lineGroup) {\n                    var topMarg = (index !== 0) ? lineGroupBuffer : 'auto';\n                    var currentIndent = ((lineGroup.maxWidth -\n                        (index * indent)) &lt; minLineWidth) ? previousIndent :\n                        (index * indent);\n                    previousIndent = currentIndent;\n\n                    var lineGroupDiv = $('&lt;div&gt;')\n                                            .addClass(lineGroupClass)\n                                            .css({'margin-left': currentIndent,\n                                                'margin-top': topMarg});\n                    var end = begin + lineGroup.spanWidths.length;\n                    container.children().clone().each(\n                        function (index, line) {\n                            lineGroupDiv.append(\n                                $(line)\n                                    .html($(line).children().slice(begin, end)));\n                        }\n                    );\n                    newContainer.append(lineGroupDiv);\n                    begin = end;\n                });\n\n                // Replace the container's children with those of the new container\n                container.html(newContainer.children());\n            }\n        });\n    }\n\n})(jQuery); \n</code></pre>\n", "Id":"1819", "ParentId":"3", "CreationDate":"2012-04-19T05:54:47.507", "Score":"1", "PostTypeId":"2", "OwnerUserId":"940", "LastActivityDate":"2012-04-19T05:54:47.507", "OwnerUser":{"UpVotes":"0", "DownVotes":"0", "Id":"940", "AccountId":"1417911", "Views":"2", "Reputation":"11", "CreationDate":"2012-04-19T05:54:47.523", "DisplayName":"Joel", "LastAccessDate":"2012-04-23T23:41:40.720"}}